<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
    <div class="reveal">
      <div class="slides">
        <section data-background-color="#EEEEEE" data-background-image="images/Fizim34.jpg" data-background-size="contain" data-background-position="25%" data-background-transition="slide">
          <h3 style="filter: drop-shadow(5px 5px 4px #333333);">Tilt-Shift Rendering Using a Thin Lens Model</h3>
          <p style="filter: drop-shadow(5px 5px 4px #333333);">
            <small>
              Presented by <b>Kenneth Lamar</b>
            </small>
          </p>
          <aside class="notes">
            Hello everyone. My name is Kenneth Lamar, and today I will be talking about tilt-shift rendering using the thin lens model. Simulating a tilt-shift lens in ray tracing enables us to accurately simulate several advanced real-world photography techniques.
          </aside>
        </section>
        <section id="visual">
          <svg id="illus" class="svg" width="450" height="450"></svg>
          <canvas id="render" width="450" height="450"></canvas>
        </section>
				<section>
          <img src="images/Tilt-lens_photo_of_model_train.jpg" style="max-width: 100%; max-height: 100%;">
          <aside class="notes">
            You can see this showcased in this image of a model train. Even though the depth of field is quite strong, the entire train remains in focus, as the focal plane has been tilted.
          </aside>
        </section>
        <!-- TODO: Math? -->
        <section>
          <h3 style="filter: drop-shadow(5px 5px 4px #333333);">How it Works</h3>
          <aside class="notes">
            So we have talked about what we are trying to do. Now, let's talk broadly about how to do it.
          </aside>
        </section>
        <section>
          <img src="images/correction.png" style="max-width: 100%; height: 400px;">
          <img class="fragment fade-in" src="images/Psolve.png"> 
          <aside class="notes">
            Every ray starts by being fired out from some point on the image sensor. We call this point P'. It starts at some point on the sensor relative to the associated pixel, just like in our assignments throughout the semester. We then shoot it in a direction toward the origin, the center point of the thing lens, O. To simulate the imperfect angle of the way light hits the lens, we apply a random offset to where it actually hits the lens. That's why O here isn't in the center. Finally, that ray gets redirected by the lens and shoots off toward the associated point on the focal plane, P. 
            P is calculated using the below equation. It relates to the location on the image sensor, the focal length, and the distance to the sensor.
            A more intuitive way for me to calculate P is by getting the direction vector between the starting point, P', and the origin of the lens. This is the direction the light would travel if it didn't need any correction. We can use this direction to find the intersection point at the focal plane, which is P. To make our ray go toward P, our final ray's origin is set to O and its final direction is set to go from O toward P. In this way, every ray is perfectly directed when it hits objects on the focal plane, but anything in front of or behind that plane could be directed imperfectly, causing blur.
            To add support for shifting is quite simple. You merely take whatever point P you would normally get and offset it by some amount on the X and Y axes.
          </aside>
        </section>
        <section>
          <img src="images/tilt.png" style="max-width: 100%; height: 400px;">
          <img class="fragment fade-in" src="images/Psolve.png" style="margin-right:10%; opacity: 50%">
          <img class="fragment fade-in" src="images/PsolveTilt.png"> 
          <aside class="notes">
            Handling tilt is more involved. The distance between the lens plane and the focal plane remains unchanged in the center, but finding O and P becomes more complex. In this case, we calculate basis vectors, u and v, which indicate the angle of the lens. u points right relative to the lens and v points up. Now to compute O, we find some random offset along the rotated lens plane using those basis vectors.
            Computing P uses a slightly more complex version of the equation used before. Unlike before, now we compute P' dot t-hat instead of s. T-hat is the direction the lens has tilted to face. This takes P' and redirects it according to the lens rotation.
          </aside>
        </section>
        <section data-markdown>
          ## In Closing
          - The tilt-shift camera model simulates advanced, real-world photography techniques
          - The thin lens model simplifies the needed computations
          - Once rays are redirected, they are traced as per normal
        </section>
        <section>
          <h3 style="filter: drop-shadow(5px 5px 4px #333333);">Thank You!</h3>
          <p style="filter: drop-shadow(5px 5px 4px #333333);">
            <a href="/sliderDemo.html">
              Interactive Demo
              <br>
              <img src="images/preview.png" style="max-width: 20%; max-height: 20%;">
            </a>
          </p>
          <aside class="notes">
            I have an interactive version of my 2D visualization available to mess around with. Most combinations of values and effects are properly handled. I encourage anyone who is interested give it a try. It has control of several parameters I didn't need for this presentation.
          </aside>
        </section>
			</div>
		</div>
    
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>

    <script src="js/seedrandom.js">// For deterministic Math.seedrandom()</script>
    <script src="js/twgl-full.min.js"></script>
    <script src="js/d3.v7.min.js" charset="utf-8"></script>
    <div class="slidecontainer">
      <a>Ray Count: </a>
      <input type="range" min="1" max="100" value="5" step="1" class="slider" id="rayCount">
      <a>Ray Grouping: </a>
      <input type="range" min="0" max="1" value="0" step="0.001" class="slider" id="rayGrouping">
      <br>
      <a>Ray Sensor Distance: </a>
      <input type="range" min="0" max="1" value="0" step="0.001" class="slider" id="raySensorDistance">
      <a>Ray Distance: </a>
      <input type="range" min="0" max="2" value="0" step="0.001" class="slider" id="rayDistance">
      <br>
      <a>Ray Angle: </a>
      <input type="range" min="-2" max="2" value="0" step="0.001" class="slider" id="rayAngle">
      <a>Deviation: </a>
      <input type="range" min="0" max="1" value="0" step="0.001" class="slider" id="deviation">
      <a>Correction: </a>
      <input type="range" min="0" max="1" value="1" step="0.001" class="slider" id="correction">
      <a>F/stop: </a>
      <input type="range" min="0.01" max="10" value="5" step="0.001" class="slider" id="n">
      <br>
      <div id="constraintChooser">
        <a>Dependent Param: </a>
        <input type="radio" id="sRadio" name="constraintChooser" value="s" checked>
        <label for="sRadio">Sensor Distance</label>
        <input type="radio" id="fRadio" name="constraintChooser" value="f">
        <label for="fRadio">Focal Length</label>
        <input type="radio" id="pRadio" name="constraintChooser" value="p">
        <label for="pRadio">Focal Plane Distance</label>
      </div>
      <a>Sensor Distance: </a>
      <input type="range" min="1.01" max="5" value="2" step="0.001" class="slider" id="s">
      <a>Focal Length: </a>
      <input type="range" min="0.01" max="2" value="1" step="0.001" class="slider" id="f">
      <a>Focal Plane Distance: </a>
      <input type="range" min="1.01" max="5" value="3" step="0.001" class="slider" id="p">
      <br>
      <a>Shift X: </a>
      <input type="range" min="-10" max="10" value="0" step="0.001" class="slider" id="shiftX">
      <a>Shift Y: </a>
      <input type="range" min="-10" max="10" value="0" step="0.001" class="slider" id="shiftY">
      <a>Tilt X: </a>
      <input type="range" min="-1" max="1" value="0" step="0.001" class="slider" id="tiltX">
      <a>Tilt Y: </a>
      <input type="range" min="-1" max="1" value="0" step="0.001" class="slider" id="tiltY">
      <br>
      <a>Sensor Size: </a>
      <input type="range" min="0.1" max="5" value="1.8" step="0.001" class="slider" id="sensorSize">
      <a>Element Scale: </a>
      <input type="range" min="0" max="1" value="0" step="0.001" class="slider" id="elementScale">
      <a>Diagram Fade: </a>
      <input type="range" min="0" max="255" value="0" step="1" class="slider" id="diagramFade">
      <a>Gauss Fade: </a>
      <input type="range" min="0" max="255" value="0" step="1" class="slider" id="gaussFade">
    </div>
    <div id="gaussEqDiv" style="display: none;">
      <svg id="gaussEq" xmlns="http://www.w3.org/2000/svg" width="98.264px" height="40.416px" viewBox="0 -1342 5429 2233" xmlns:xlink="http://www.w3.org/1999/xlink" style=""><defs><path id="MJX-17-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-17-TEX-I-66" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path><path id="MJX-17-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-17-TEX-I-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-17-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-17-TEX-I-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(245, 676)"><use xlink:href="#MJX-17-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(220, -686)"><use xlink:href="#MJX-17-TEX-I-66"></use></g><rect width="750" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(1267.8, 0)"><use xlink:href="#MJX-17-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(2323.6, 0)"><g data-mml-node="mn" transform="translate(221.5, 676)"><use xlink:href="#MJX-17-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(220, -686)"><use xlink:href="#MJX-17-TEX-I-70"></use></g><rect width="703" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(3488.8, 0)"><use xlink:href="#MJX-17-TEX-N-2B"></use></g><g data-mml-node="mfrac" transform="translate(4489, 0)"><g data-mml-node="mn" transform="translate(220, 676)"><use xlink:href="#MJX-17-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(235.5, -686)"><use xlink:href="#MJX-17-TEX-I-73"></use></g><rect width="700" height="60" x="120" y="220"></rect></g></g></g></svg>
    </div>
    <script id="helpers">
      function padLeadingZeros(num, size) {
          var s = num+"";
          while (s.length < size) s = "0" + s;
          return s;
      }
      function HSVtoRGB(h, s, v) {
        var r, g, b, i, f, p, q, t;
        if (arguments.length === 1) {
          s = h.s, v = h.v, h = h.h;
        }
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0: r = v, g = t, b = p; break;
          case 1: r = q, g = v, b = p; break;
          case 2: r = p, g = v, b = t; break;
          case 3: r = p, g = q, b = v; break;
          case 4: r = t, g = p, b = v; break;
          case 5: r = v, g = p, b = q; break;
        }
        var str = "#" +
                  padLeadingZeros(Math.round(r * 255).toString(16),2) +
                  padLeadingZeros(Math.round(g * 255).toString(16),2) +
                  padLeadingZeros(Math.round(b * 255).toString(16),2);
        return str;
      }
      // Curve helper function.
      var curveFunc = d3.line()
                        .curve(d3.curveCatmullRomClosed) // http://bl.ocks.org/d3indepth/b6d4845973089bc1012dec1674d3aff8
                        .x(function(d) { return d[0] })
                        .y(function(d) { return d[1] });
      var lineFunc = d3.line()
                       .x(function(d) { return d[0] })
                       .y(function(d) { return d[1] });
      // NOTE: Arrays are pass-by-reference, so this will affect the array passed in directly.
      function shiftCoords(coords) {
        for(var i = 0; i < coords.length; i++) {
          coords[i][0] *= svgScale;
          coords[i][1] *= svgScale;
          coords[i][0] += centerW;
          coords[i][1] += centerH;
        }
        return coords;
      }
    </script>
    <script id="vars">
      // Controllable variables. Set by sliders and animations.
      var rayCount; // Used for illustration only. Defines the number of rays visualized in illustration.
      var rayGrouping; // [0-1]. Used for illustration only. Groups lines together to show multiple angles from a single source.
      var raySensorDistance; // Used for illustration only. Multiplier. Used to denote how far to the sensor to draw.
      var rayDistance; // Used for illustration only. Multiplier. Used to denote how far past to focal plane to draw.
      var rayAngle; // Used for illustration only. Shows how rays are affected by hitting at different angles. Could be used in render for adjusting angle on y axis too?
      var deviation; // [0-1]. Used for the illustration only. Deviates the rays; potentially beyond the aperture; with those rays being culled at the lens. Could be used in render to permit some samples to deviate outside the aperture and return 0?
      var correction; // [0-1]. Defines strength of the lens. Either permits blurriness as though the lens isn't there (0) or corrects to focal plane (1).
      var s; // The distance between the sensor and lens. Dependent on f and p. Adjustable by real cameras.
      var f; // Focal length of the lens. Used to adjust field of view.
      var p; // Distance from lens to focal plane. Used to adjust what distance is in focus.
      var n; // Aperture diameter for F-stop. Used to block more or less light (used to compute aperture), affecting sharpness. Used in illustration to adjust deviation.
      var shift = [0,0]; // Defines the shifting of the images sensor relative to the lens origin.
      var tilt = [0,0,-1]; // A vector defining the tilt angle of the lens.
      var sensorSize; // Physical footprint of the lens. Used to determine the footprint where rays can shoot from the sensor.
      var elementScale; // Animation-only sensor scale.
      var diagramFade; // Animation-only diagram component transparency.
      var gaussFade; // Animation-only Gauss component transparency.
      // Standard variables that can simply be initialized from their slider values.
      var variables = [
        "rayCount",
        "rayGrouping",
        "raySensorDistance",
        "rayDistance",
        "rayAngle",
        "deviation",
        "correction",
        "f",
        "p",
        "n",
        "sensorSize",
        "elementScale",
      ];
      // Internal variables. These are dependent on the other variables.
      var aperture; // The aperture ultimately determines how sharp the image is. Computed from f and n.
      var basis_u = [1,0,0]; // The basis vectors used to determine lens intersection when tilted. U is for horizontal movement.
      var basis_v = [0,1,0]; // The basis vectors used to determine lens intersection when tilted. V is for vertical movement.

      var svg; // A reference to our SVG canvas.
      var svgScale = 70; // A scale factor to deal with small numbers on the graph.
      // Center-point offsets for the canvas.
      var centerW;
      var centerH;
      // Label positioning variables.
      var labelOffset = 0.1;
      var labelPos = 10;
    </script>
    <script id="sliderVars">
      // Slider variables.
      var rayCountSlider = document.getElementById("rayCount");
      var rayGroupingSlider = document.getElementById("rayGrouping");
      var raySensorDistanceSlider = document.getElementById("raySensorDistance");
      var rayDistanceSlider = document.getElementById("rayDistance");
      var rayAngleSlider = document.getElementById("rayAngle");
      var deviationSlider = document.getElementById("deviation");
      var correctionSlider = document.getElementById("correction");
      var fSlider = document.getElementById("f");
      var pSlider = document.getElementById("p");
      var sSlider = document.getElementById("s");
      var nSlider = document.getElementById("n");
      var shiftXSlider = document.getElementById("shiftX");
      var shiftYSlider = document.getElementById("shiftY");
      var tiltXSlider = document.getElementById("tiltX");
      var tiltYSlider = document.getElementById("tiltY");
      var sensorSizeSlider = document.getElementById("sensorSize");
      var elementScaleSlider = document.getElementById("elementScale");
      var diagramFadeSlider = document.getElementById("diagramFade");
      var gaussFadeSlider = document.getElementById("gaussFade");
    </script>
    <script id="illusFuncs">
      // Generate a ray for illustration.
      function getRay(percent, random) {
        // Given a percent along the image sensor, find the associated point, P'.
        // P' is the location where the ray touches the sensor.
        // NOTE: We can make x and y negative to correct for a reversed image.
        // NOTE: We eventually discard the x-axis in 2D space. It can have garbage for all we care.
        var PPrime = [
          shift[0],
          (percent - 0.5) * sensorSize + shift[1],
          -s
        ];

        // Uniformly sample from a circular disk for the Bokeh shape.
        var theta = 6.28318531 * random[0];
        // A random factor used to position the ray onto the lens.
        // The shape of the lens means any random positioning will still converge rays on the focal plane.
        // Multiply by the aperture to keep rays of being culled by hitting a wall.
        var r = aperture * random[1] * deviation;

        // The spot where the ray hits the lens.
        // The origin hit point is somewhat randomized, along the basis vectors.
        var O = twgl.v3.mulScalar(twgl.v3.add(twgl.v3.mulScalar(basis_u, Math.cos(theta)),
                                              twgl.v3.mulScalar(basis_v, Math.sin(theta))),
                                  r);
        // Offset ray hit point for all rays.
        // TODO: Not actually correct in tilted case.
        O[1] = O[1] + rayAngle * aperture;
        // Now solve P, the location where the ray touches the focal plane.
        // NOTE: Paper authors got this wrong by adding. Simply negate instead to make it go the right direction.
        var P = twgl.v3.mulScalar(PPrime, f/(f-twgl.v3.dot(PPrime,tilt)));

        // Now figure out what to draw with this information.
        // Find dirPrime, the direction the ray goes between the lens and the sensor.
        var dirPrime = twgl.v3.normalize(twgl.v3.subtract(PPrime,O));
        // Figure out where the ray hits the sensor plane.
        var distPPrime = PPrime[2]/dirPrime[2];
        // Draw a line from the lens to the focal plane.
        // Find dirP, the direction the ray goes leaving the lens.
        var dirP = twgl.v3.normalize(twgl.v3.subtract(P,O));
        // Figure out where the ray hits the focal plane.
        var distP = P[2]/dirP[2];
        // Get the final location of each ray, (partially) scaled and corrected.
        var length = (P[2]-O[2])/dirP[2];
        var final = twgl.v3.add(O,
                    twgl.v3.add(twgl.v3.mulScalar(dirP,correction*length*rayDistance),
                                twgl.v3.mulScalar(dirPrime,-1*(1-correction)*length*rayDistance)));
        // Assemble the final array of points.
        var ray = [[PPrime[2]*raySensorDistance + O[2]*(1-raySensorDistance),
                    PPrime[1]*raySensorDistance + O[1]*(1-raySensorDistance)],
                   [O[2],O[1]],
                   [final[2],final[1]]];
        // Remove part of the ray if it can't get through the aperture.
        if(O[1] > aperture || O[1] < -aperture) {
          ray.pop();
          // ray.shift();
        }
        // Return an array of points.
        // These will be drawn as a line to illustrate a ray.
        return ray;
      }
      function drawLine(points, color, thickness, id) {
        return svg.append("path")
                  .attr("id", id)
                  // NOTE: SVGs draw with coordinates from the top-left. Use width and height attributes to compensate so 0,0 is the center.
                  .attr('d', lineFunc(shiftCoords(points)))
                  .attr('stroke', color)
                  .style("stroke-width", function(d) { return thickness; })
                  .attr('fill', 'none');
      }
      function draw() {
        // Clear the canvas.
        svg.selectAll('*').remove();
        // Get the centerpoint of the SVG.
        centerW = parseInt(svg.style("width"))/2;
        centerH = parseInt(svg.style("height"))/2;

        // Define the SVG arrowhead.
        svg.append("svg:defs").append("svg:marker")
           .attr("id", "triangle")
           .attr("refX", 3)
           .attr("refY", 3)
           .attr("markerWidth", 30)
           .attr("markerHeight", 30)
           .attr("orient", "auto")
           .attr('orient', 'auto-start-reverse')
           .append("path")
           .attr("d", "M 0 0 6 3 0 6 3 3")
           .style("fill", "#000000"+gaussFade);
           
        // Draw center line.
        drawLine([[-centerW,0],[centerW,0]], "#888888"+diagramFade, 4, "centerLine");
        // Draw each ray.
        for (var i = rayCount-1; i >= 0; i--) {
          var percent;
          if (rayCount > 1) {
            percent = i/(rayCount - 1)*(1-rayGrouping);
          }
          else {
            percent = 0.5;
          }
          //Math.seedrandom(i)
          //var ray = getRay(percent, [Math.random(), Math.random()]);
          // TODO: Using the pre-generated random numbers causes console errors. Figure out why.
          var ray = getRay(percent, [rand[2*i], rand[2*i+1]]);
          drawLine(ray, HSVtoRGB(i/(rayCount)*.75,1,1), Math.min(4,40/rayCount));
        }

        // TODO: Add axis labels?

        // Gauss' Thin Lens Equation Visualizations.
        // s
        drawLine([[-s+.1,-sensorSize],[-.1,-sensorSize]], "#000000"+gaussFade, 2)
                 .attr("marker-end", "url(#triangle)")
                 .attr("marker-start", "url(#triangle)");
        svg.append("text")
           .attr("x", centerW-s/2*svgScale)
           .attr("y", centerH+(-sensorSize-.1)*svgScale)
           .style("fill", "#000000"+gaussFade)
           .text("s="+s);
        // p
        drawLine([[.1,-sensorSize],[p-.1,-sensorSize]], "#000000"+gaussFade, 2)
                 .attr("marker-end", "url(#triangle)")
                 .attr("marker-start", "url(#triangle)");
        svg.append("text")
           .attr("x", centerW+p/2*svgScale)
           .attr("y", centerH+(-sensorSize-.1)*svgScale)
           .style("fill", "#000000"+gaussFade)
           .text("p="+p);
        // f/n
        drawLine([[.3,-aperture],[.3,aperture]], "#000000"+gaussFade, 2)
                 .attr("marker-end", "url(#triangle)")
                 .attr("marker-start", "url(#triangle)");
        svg.append("text")
           .attr("x", centerW+.4*svgScale)
           .attr("y", centerH)
           .style("fill", "#000000"+gaussFade)
           .text("f/n="+aperture);
        // Gauss' Thin Lens Equation.
        svg.append("text")
           .attr("x", centerW-0.1*svgScale)
           .attr("y", -1*svgScale+(1.3*svgScale)*Number("0x"+gaussFade)/255)
           .style("fill", "#000000")
           .style("text-anchor", "end")
           .text("Gauss' Thin Lens Equation:");
        var gaussEq = document.getElementById("gaussEq");
        svg.append("g")
           .attr("x", "98.264px")
           .attr("y", "40.416px")
           .style("fill", "#000000"+gaussFade)
           .attr("transform", function(d) { return "translate(" + 
             [centerW+0.1*svgScale, 
             -1*svgScale+(1.2*svgScale)*Number("0x"+gaussFade)/255] + ")"; })
           .html(gaussEq.outerHTML);

        // These variables are used to track the lens rotation for use in visualization.
        var lensCorner = twgl.v3.mulScalar(basis_u, aperture);
        var lensSide = twgl.v3.normalize(twgl.v3.cross([1,0,0],lensCorner));
        var lensCurvePos = twgl.v3.mulScalar(lensSide, correction*0.2*elementScale);

        // Draw planes.
        // Image plane.
        drawLine([[-s,centerH],[-s,-centerH]], "#000000"+diagramFade, 2, "imagePlane")
                 .style("stroke-dasharray", ("15, 5"));
        // Lens plane.
        // Get the scale needed to go to the end of the diagram after rotation.
        var lensPlaneScale = centerH/lensCorner[1];
        drawLine([[lensCorner[2]*lensPlaneScale,lensCorner[1]*lensPlaneScale],
                  [-lensCorner[2]*lensPlaneScale,-lensCorner[1]*lensPlaneScale]], 
                  "#000000"+diagramFade, 2, "lensPlane")
                  .style("stroke-dasharray", ("15, 5"));
        // Focal plane.
        // Get an origin and direction for the plane.
        // Start by getting two points from the sensor and determine where they would hit the focal plane.
        var focalPlanePPrime = [shift[0],0.5 * sensorSize + shift[1],-s];
        var focalPlaneP1 = twgl.v3.mulScalar(focalPlanePPrime, f/(f-twgl.v3.dot(focalPlanePPrime,tilt)));
        focalPlanePPrime[1] = -focalPlanePPrime[1];
        var focalPlaneP2 = twgl.v3.mulScalar(focalPlanePPrime, f/(f-twgl.v3.dot(focalPlanePPrime,tilt)));
        // The difference between the points is the direction vector, which we can use to find points along the focal plane.
        var focalPlaneDir = twgl.v3.normalize(twgl.v3.subtract(focalPlaneP1,focalPlaneP2));
        if(focalPlaneDir[1] == 0) {
          var focalPlaneStart = [0,-centerH,-s];
          var focalPlaneEnd = [0,centerH,-s];
        }
        else {
          // This is the length that must be traveled for the line to extend from the bottom to the top of the illustration.
          var focalPlaneLen = (-centerH-focalPlaneP1[1])/focalPlaneDir[1];
          // Now compute the specific points from one end of the line to the other.
          var focalPlaneStart = twgl.v3.add(focalPlaneP1,twgl.v3.mulScalar(focalPlaneDir,focalPlaneLen));
          var focalPlaneEnd = twgl.v3.subtract(focalPlaneP1,twgl.v3.mulScalar(focalPlaneDir,focalPlaneLen));
        }
        // Finally, draw the line.
        drawLine([[focalPlaneStart[2],focalPlaneStart[1]],[focalPlaneEnd[2],focalPlaneEnd[1]]], "#000000"+diagramFade, 2, "focalPlane").style("stroke-dasharray", ("15, 5"));

        // Draw sensor.
        drawLine([[-s,sensorSize/2*elementScale+shift[1]],
                  [-s,-sensorSize/2*elementScale+shift[1]]], "#8BC63E", 8, "sensor");
        // Draw lens.
        drawLine([[lensCorner[2],lensCorner[1]*elementScale],[-lensCorner[2],-lensCorner[1]*elementScale]], "#6A81BF", 4, "lensThin");
        svg.append("path")
           .attr("id", "lens")
           .attr("d", curveFunc(shiftCoords([[-lensCorner[2],-lensCorner[1]*elementScale],
                                             [lensCurvePos[2],lensCurvePos[1]],
                                             [lensCorner[2],lensCorner[1]*elementScale],
                                             [-lensCurvePos[2],-lensCurvePos[1]]])))
           .attr("stroke", "#6A81BF")
           .style("stroke-width", function(d) { return 4; })
           .attr("fill","#6A81BF50");
        // Draw labels.
        svg.append("text")
           .attr("x", centerW+(labelOffset-s)*svgScale)
           .attr("y", 2*centerH-labelPos)
           .style("fill", "#000000"+diagramFade)
           .text("Image Plane");
        svg.append("text")
           .attr("x", lensCorner[2]*lensPlaneScale+centerW+labelOffset*svgScale)
           .attr("y", 2*centerH-labelPos)
           .style("fill", "#000000"+diagramFade)
           .text("Lens Plane");
        svg.append("text")
           .attr("x", centerW+(labelOffset+p)*svgScale)
           .attr("y", 2*centerH-labelPos)
           .style("fill", "#000000"+diagramFade)
           .text("Focal Plane");
      }
      var rand = [];
      function init() {
        // Get the initial parameter values from the sliders.
        for (var v in variables) {
          window[variables[v]] = Number(window[variables[v]+"Slider"].value);
        }
        shift[0] = Number(shiftXSlider.value);
        shift[1] = Number(shiftYSlider.value);
        tilt[0] = Number(tiltXSlider.value);
        tilt[1] = Number(tiltYSlider.value);
        diagramFade = padLeadingZeros(Number(diagramFadeSlider.value).toString(16),2);
        gaussFade = padLeadingZeros(Number(gaussFadeSlider.value).toString(16),2);
        // Lock the s parameter slider.
        sSlider.disabled = true;
        // Initialize the internal variables.
        s = (p*f)/(p-f);
        aperture = f/n;
        basis_u = twgl.v3.normalize(twgl.v3.cross(tilt,
                           Math.abs(tilt.x) > Math.abs(tilt.y)
                           ? [0,1,0] : [1,0,0]));
        basis_v = twgl.v3.cross(tilt, basis_u);
        // Pre-generate our random numbers.
        Math.seedrandom(0);
        for( var i = 0; i < rayCountSlider.max * 2; i++) {
          rand.push(Math.random());
        }
        // Get the SVG reference.
        svg = d3.select("body").select("#illus");
        // Draw the initial image.
        draw();
      }
      // Run the init function on page load.
      init();
    </script>
    <script id="sliderFuncs">
      rayCountSlider.oninput = function() {
        rayCount = Number(this.value);
        draw();
      }
      rayGroupingSlider.oninput = function() {
        rayGrouping = Number(this.value);
        draw();
      }
      rayDistanceSlider.oninput = function() {
        rayDistance = Number(this.value);
        draw();
      }
      raySensorDistanceSlider.oninput = function() {
        raySensorDistance = Number(this.value);
        draw();
      }
      rayAngleSlider.oninput = function() {
        rayAngle = Number(this.value);
        draw();
      }
      deviationSlider.oninput = function() {
        deviation = Number(this.value);
        draw();
      }
      correctionSlider.oninput = function() {
        correction = Number(this.value);
        draw();
      }
      if (document.querySelector('input[name="constraintChooser"]')) {
        document.querySelectorAll('input[name="constraintChooser"]').forEach((elem) => {
          elem.addEventListener("change", function(event) {
            // Unlock all Gauss' Thin Lens sliders.
            sSlider.disabled = false;
            fSlider.disabled = false;
            pSlider.disabled = false;
            // Lock the selected parameter.
            window[event.target.value+"Slider"].disabled = true;
          });
        });
      }
      sSlider.oninput = function() {
        s = Number(this.value);
        // Update internal variables dependent on this.
        if(pSlider.disabled) {
          p = (s*f)/(s-f);
        }
        else { // fSlider.disabled
          f = 1/(1/p+1/s);
        }
        draw();
      }
      fSlider.oninput = function() {
        f = Number(this.value);
        // Update internal variables dependent on this.
        if(pSlider.disabled) {
          p = (s*f)/(s-f);
        }
        else { // sSlider.disabled
          s = (p*f)/(p-f);
        }
        aperture = f/n;
        draw();
      }
      pSlider.oninput = function() {
        p = Number(this.value);
        // Update internal variables dependent on this.
        if(fSlider.disabled) {
          f = 1/(1/p+1/s);
        }
        else { // sSlider.disabled
          s = (p*f)/(p-f);
        }
        draw();
      }
      nSlider.oninput = function() {
        n = Number(this.value);
        // Update internal variables dependent on this.
        aperture = f/n;
        draw();
      }
      shiftXSlider.oninput = function() {
        shift[0] = Number(this.value);
        draw();
      }
      shiftYSlider.oninput = function() {
        shift[1] = Number(this.value);
        draw();
      }
      tiltXSlider.oninput = function() {
        tilt[0] = Number(this.value);
        // Update internal variables dependent on this.
        basis_u = twgl.v3.normalize(twgl.v3.cross(tilt,
                           Math.abs(tilt.x) > Math.abs(tilt.y)
                           ? [0,1,0] : [1,0,0]));
        basis_v = twgl.v3.cross(tilt, basis_u);
        draw();
      }
      tiltYSlider.oninput = function() {
        tilt[1] = Number(this.value);
        // Update internal variables dependent on this.
        basis_u = twgl.v3.normalize(twgl.v3.cross(tilt,
                           Math.abs(tilt.x) > Math.abs(tilt.y)
                           ? [0,1,0] : [1,0,0]));
        basis_v = twgl.v3.cross(tilt, basis_u);
        draw();
      }
      sensorSizeSlider.oninput = function() {
        sensorSize = Number(this.value);
        draw();
      }
      elementScaleSlider.oninput = function() {
        elementScale = Number(this.value);
        draw();
      }
      diagramFadeSlider.oninput = function() {
        diagramFade = padLeadingZeros(Number(this.value).toString(16),2);
        draw();
      }
      gaussFadeSlider.oninput = function() {
        gaussFade = padLeadingZeros(Number(this.value).toString(16),2);
        draw();
      }
    </script>
    <script id="renderShaders">
      vs = `#version 300 es
in vec4 position;

void main() {
  gl_Position = position;
}
      `;
      fs = `#version 300 es
precision mediump float;

const float INFINITY = 10000000000000000000000000000000.;

uniform vec2 iResolution;
uniform float iTime;
out vec4 FragColor;

uniform float deviation;
uniform float correction;
uniform float s;
uniform float f;
uniform float p;
uniform float n;
uniform vec2 shift;
uniform vec3 tilt;
uniform float sensorSize;
uniform float aperture;
uniform vec3 basis_u;
uniform vec3 basis_v;

#define GRID 0 // 0 = diffuse grey grid, 1 = emissive spots
const vec3 blue_sphere = vec3(0.75, 0.5, 0.25);
const vec3 green_sphere = vec3(-0.5, -0.25, 0.75);
const vec3 red_sphere = vec3(0.25, -0.75, -0.5);

// Camera parameters. 
// Change these to reposition the camera, move the points of focus, or change the lens and camera parameters.
// Not all combinations are physically possible.
const vec3 eye = vec3(0.0, 0.0, -2.75);

// Derived constants from above settings.
const vec3 gaze = normalize(-eye);
const vec3 right = normalize(cross(gaze, vec3(0.0, 1.0, 0.0)));
const vec3 up = cross(gaze, right);
const float epsilon = 0.001;

struct Ray {
  vec3 origin;
  vec3 direction;
  float tMin, tMax;
};
struct RayPayload {
  vec3 color;
};

Ray tiltShift(vec2 screen, vec2 random) {
  vec3 PPrime = vec3(screen*0.5*sensorSize+shift, -s);

  // TODO: Ensure random numbers come pre-squared.
  float theta = 6.28318531 * random.x;
  float r = 0.5 * aperture * sqrt(random.y);
  vec3 O = (cos(theta) * basis_u + sin(theta) * basis_v) * r;

  vec3 P = PPrime * f / (f - dot(PPrime, tilt));

  Ray ray;
  ray.origin = O;
  ray.direction = normalize(P - O);
  ray.tMin = 0.;
  ray.tMax = INFINITY;
  return ray;
}

// Ray/primitive intersection routines. Take the ray origin and
// direction, and the primitive position as input. If the
// t-value for the distance to the intersection is closer than
// the existing t-value passed in, then updates the t-value, the
// hit coordinates, and surface normal at the intersection.
int plane(
    vec3 origin,
    vec3 direction,
    vec3 orient,
    float offset,
    inout float t,
    inout vec3 hit,
    inout vec3 normal) {
  float t_plane = (offset - dot(origin, orient)) / dot(direction, orient);
  if (t_plane < epsilon || t < t_plane)
      return 0;
  t = t_plane;
  hit = origin + direction * t;
  normal = orient;
  return 1;
}
int sphere(
    vec3 origin,
    vec3 direction,
    vec3 center,
    float radius,
    inout float t,
    inout vec3 hit,
    inout vec3 normal) {
  vec3 offset = origin - center;
  float b = dot(offset, direction);
  float c = dot(offset, offset) - radius * radius;
  float discriminant = b * b - c;
  if (discriminant <= 0.0)
      return 0;
  float t_sphere = -b - sqrt(discriminant);
  if (t_sphere < epsilon || t < t_sphere)
      return 0;
  t = t_sphere;
  hit = origin + direction * t;
  normal = normalize(hit - center);
  return 1;
}
int cylinder(
    vec3 origin,
    vec3 direction,
    vec3 center,
    vec3 orient,
    float radius,
    inout float t,
    inout vec3 hit,
    inout vec3 normal) {
  vec3 approach = cross(direction, orient);
  float distance = abs(dot(origin - center, normalize(approach)));
  if (distance > radius)
      return 0;
  float t_center = dot(cross(orient, origin - center), approach) /
      dot(approach, approach);
  float t_half = sqrt(radius * radius - distance * distance) /
      dot(direction, normalize(cross(orient, approach)));
  float t_cylinder = t_center - t_half;
  if (t_cylinder < epsilon || t < t_cylinder)
      return 0;
  t = t_cylinder;
  hit = origin + direction * t;
  normal = ((hit - center) - dot(hit - center, orient) * orient) / radius;
  return 1;
}

// Shade a 2D position to compute either a grey grid pattern with
// lines to use for diffuse shading or else a grey pattern with a
// grid of small dots to use for emissive shading.
float grid_diffuse(
    vec2 position) {
#if GRID == 0
  vec2 cell = fract(position);
  vec2 grid_1 = step(0.015, cell) - step(0.985, cell);
  vec2 grid_2 = 1.0 - step(0.475, cell) + step(0.525, cell);
  float blend = mod(floor(position.x) + floor(position.y), 2.0);
  return mix(0.4, grid_1.x * grid_1.y * mix(grid_2.x * grid_2.y, 0.9, blend), 0.6);
#else
  return 0.0;
#endif
}
float grid_emissive(vec2 position) {
#if GRID == 1
  vec2 cell = fract(position);
  vec2 centered = cell - vec2(0.5);
  return 20.0 * (1.0 - step(0.001, dot(centered, centered)));
#else
  return 0.0;
#endif
}

// Random number generation. Map a 3D seed value to a group of
// three pseudorandom each in [0,1]. (I.e., a uniformly
// distributed sample in the unit 3D cube.)
vec3 rng(vec3 seed) {
  uvec3 v = uvec3(abs(seed) * 1048576.0);
  v = v * 1664525u + 1013904223u;
  v.x += v.y * v.z;
  v.y += v.z * v.x;
  v.z += v.x * v.y;
  v ^= v >> 16u;
  v.x += v.y*v.z;
  v.y += v.z*v.x;
  v.z += v.x*v.y;
  return vec3(v) * (1.0 / float(0xffffffffu));
}
// Given a ray and a maximum distance t-value, intersect the ray
// against the scene and get information out about what was hit
// if anything. The position and shading values at the hit are
// output. Returns 1 if the ray hit anything, or 0 if it missed.
int trace(
    vec3 origin,
    vec3 direction,
    float t,
    out vec3 hit,
    out vec3 normal,
    out vec3 diffuse,
    out vec3 specular,
    out vec3 emissive) {
  const vec3 x_axis = vec3(1.0, 0.0, 0.0);
  const vec3 y_axis = vec3(0.0, 1.0, 0.0);
  const vec3 z_axis = vec3(0.0, 0.0, 1.0);
  float original_t = t;
  if (plane(origin, direction, -z_axis, -1.0, t, hit, normal) > 0) {
    diffuse = vec3(grid_diffuse(hit.xy * 4.0));
    specular = vec3(0.0);
    emissive = vec3(grid_emissive(hit.xy * 4.0));
  }
  if (plane(origin, direction,  x_axis, -1.0, t, hit, normal) +
      plane(origin, direction, -x_axis, -1.0, t, hit, normal) > 0) {
    diffuse = vec3(grid_diffuse(hit.yz * 4.0));
    specular = vec3(0.0);
    emissive = vec3(grid_emissive(hit.yz * 4.0));
  }
  if (plane(origin, direction,  y_axis, -1.0, t, hit, normal) +
      plane(origin, direction, -y_axis, -1.0, t, hit, normal) > 0) {
    diffuse = vec3(grid_diffuse(hit.xz * vec2(-4.0, 4.0)));
    specular = vec3(0.0);
    emissive = vec3(grid_emissive(hit.xz * vec2(-4.0, 4.0)));
  }
  if (sphere(origin, direction, red_sphere, 0.1, t, hit, normal) > 0) {
    diffuse = vec3(1.0, 0.1, 0.1);
    specular = vec3(0.9, 0.4, 0.4);
    emissive = vec3(0.0);
  }
  if (cylinder(origin, direction, red_sphere, x_axis, 0.01, t, hit, normal) +
      cylinder(origin, direction, red_sphere, y_axis, 0.01, t, hit, normal) +
      cylinder(origin, direction, red_sphere, z_axis, 0.01, t, hit, normal) > 0) {
    diffuse = vec3(1.0, 0.1, 0.1);
    specular = vec3(0.0);
    emissive = vec3(0.0);
  }
  if (sphere(origin, direction, green_sphere, 0.1, t, hit, normal) > 0) {
    diffuse = vec3(0.1, 1.0, 0.1);
    specular = vec3(0.4, 0.9, 0.4);
    emissive = vec3(0.0);
  }
  if (cylinder(origin, direction, green_sphere, x_axis, 0.01, t, hit, normal) +
      cylinder(origin, direction, green_sphere, y_axis, 0.01, t, hit, normal) +
      cylinder(origin, direction, green_sphere, z_axis, 0.01, t, hit, normal) > 0) {
    diffuse = vec3(0.1, 1.0, 0.1);
    specular = vec3(0.0);
    emissive = vec3(0.0);
  }
  if (sphere(origin, direction, blue_sphere, 0.1, t, hit, normal) > 0) {
    diffuse = vec3(0.1, 0.1, 1.0);
    specular = vec3(0.4, 0.4, 0.9);
    emissive = vec3(0.0);
  }
  if (cylinder(origin, direction, blue_sphere, x_axis, 0.01, t, hit, normal) +
      cylinder(origin, direction, blue_sphere, y_axis, 0.01, t, hit, normal) +
      cylinder(origin, direction, blue_sphere, z_axis, 0.01, t, hit, normal) > 0) {
    diffuse = vec3(0.1, 0.1, 1.0);
    specular = vec3(0.0);
    emissive = vec3(0.0);
  }
  return original_t == t ? 0 : 1;
}
// Path trace a ray against the scene and return an single sample
// estimating the radiance arriving at the sensor back along the
// ray. This orchestrates intersecting the ray against the
// scene, shading the ray at the hit point for the surface
// properties, next-event estimation for direct lighting from an
// invisible area light on the ceiling, and following several
// bounces of indirect rays.
vec3 shade(
    inout vec3 origin,
    inout vec3 direction) {
  vec3 shaded = vec3(0.0);
  vec3 throughput = vec3(1.0);
  for (int bounce = 0; bounce < 3; ++bounce) {
    float t = 1.0e30;
    vec3 hit = vec3(0.0);
    vec3 normal = vec3(0.0);
    vec3 diffuse = vec3(0.0);
    vec3 specular = vec3(0.0);
    vec3 emissive = vec3(0.0);
    trace(origin, direction, t, hit, normal, diffuse, specular, emissive);

    // Add in emissive contribution.
    shaded += throughput * emissive;

    // Add in direct lighting via next event estimation.
    vec3 xi_1 = rng(hit);
    vec3 light = vec3((xi_1.x - 0.5) * 0.1, 0.99, (xi_1.z - 0.5) * 0.1);
    vec3 light_direction = light - hit;
    if (dot(normal, light_direction) > 0.0)
    {
      float light_distance = length(light_direction);
      light_direction /= light_distance;
      vec3 shadow_hit = vec3(0.0);
      vec3 shadow_normal = vec3(0.0);
      vec3 shadow_diffuse = vec3(0.0);
      vec3 shadow_specular = vec3(0.0);
      vec3 shadow_emissive = vec3(0.0);
      int intersected = trace(hit, light_direction, light_distance,
                              shadow_hit, shadow_normal,
                              shadow_diffuse, shadow_specular, shadow_emissive);
      if (intersected == 0)
      {
          vec3 halfway = normalize(light_direction + normalize(origin - hit));
          float lambert = max(0.0, dot(normal, light_direction));
          float blinn_phong = 3.0 * pow(max(0.0, dot(halfway, normal)), 64.0);
          shaded += throughput * (diffuse * lambert + specular * blinn_phong);
      }
    }

    // Update for indirect lighting: adjust path throughput
    // and choose new ray for next path segment.
    float diffuse_weight = dot(diffuse, vec3(1.0));
    float specular_weight = dot(specular, vec3(1.0));
    if (xi_1.y * (diffuse_weight + specular_weight) <= diffuse_weight) {
      vec3 xi_2 = rng(hit + vec3(239.0, 491.0, 128.0));
      float phi = 6.28318531 * xi_2.x;
      float cos_theta_sq = xi_2.y;
      float sin_theta = sqrt(1.0 - cos_theta_sq);
      float sgn = normal.z < 0.0 ? -1.0 : 1.0;
      float a = -1.0 / (sgn + normal.z);
      float b = normal.x * normal.y * a;
      direction =
          (vec3(b, sgn + normal.y * normal.y * a, -normal.y) * (cos(phi) * sin_theta) +
            vec3(1.0 + sgn * normal.x * normal.x * a, sgn * b, -sgn * normal.x) * (sin(phi) * sin_theta) +
            normal * sqrt(cos_theta_sq));
      throughput *= diffuse;
    }
    else {
      direction = reflect(direction, normal);
      throughput *= specular;
    }
    origin = hit + direction * 0.001;
  }
  return shaded;
}

void mainImage(in vec2 fragCoord) {
  const float batch = 32.0;
  vec3 shaded = vec3(0.0);
  for(float i = 0.; i < batch; i++) {
    vec2 jittered = fragCoord + rng(vec3(fragCoord, iTime * i)).xy;
    vec2 screen = (2.0 * jittered - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 random = rng(vec3(screen, iTime)).xy;
    Ray ray = tiltShift(screen, random);
    ray.origin = eye + ray.origin.x * right + ray.origin.y * up + ray.origin.z * gaze;
    ray.direction = normalize(ray.direction.x * right + ray.direction.y * up + ray.direction.z * gaze);
    shaded += shade(ray.origin, ray.direction);
  }
  FragColor = vec4(shaded / batch, 1.0);
}

void main() {
  mainImage(gl_FragCoord.xy);
}
      `;
    </script>
    <script id="renderFuncs">
      // Get the canvas reference.
      canvas = document.getElementById("render");
      const gl = canvas.getContext('webgl2');
      const programInfo = twgl.createProgramInfo(gl, [vs, fs]);
      const arrays = {
        position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
      };
      const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
      function render(time) {
        twgl.resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const uniforms = {
          iResolution: [gl.canvas.width, gl.canvas.height],
          iTime: time * 0.001,
          deviation: deviation,
          correction: correction,
          s: s,
          f: f,
          p: p,
          n: n,
          shift: shift,
          tilt: tilt,
          sensorSize: sensorSize,
          aperture: aperture,
          basis_u: basis_u,
          basis_v: basis_v,
        };
        
        gl.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
        twgl.setUniforms(programInfo, uniforms);
        twgl.drawBufferInfo(gl, bufferInfo);
        
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    </script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
      var paramChanges = [{
        rayCount: 10,
        rayGrouping: 0,
        raySensorDistance: 0,
        rayDistance: 0,
        rayAngle: 0,
        deviation: 0,
        correction: 0,
        //s: 2,
        f: 1,
        p: 2,
        n: 2,
        shift: [0,0],
        tilt: [0,0,-1],
        sensorSize: 1.8,
        elementScale: 0,
        diagramFade: "00",
        gaussFade: "00",
        noAnimate: false,
        note: "We have already covered this in class, but I'd like to go over the thin lens model, as my project builds directly on top of it."
      },
      { rayDistance: 1,
        note: "Here is our traditional camera. It simulates a pinhole camera by shooting rays out of an infinitely small point. Everything is always perfectly in focus."},
      { elementScale: 1,
        note: "In real life, rays shoot into an imaging sensor or film. Now that we want to simulate a camera, we need a virtual sensor to catch the light."},
      { diagramFade: 255},
      { raySensorDistance: 1,
        note: "But now that our sensor is a surface rather than an infinitely small point, it is possible for rays to hit it from oblique angles. When rays are poorly aligned, the image will appear blurry."},
      { deviation: 1,
        note: "To correct for this blurring effect, we add a lens. The lens' job is to bring the rays back into focus by directing them to the same spots they'd hit with a perfect pinhole camera."},
      { correction: 1,
        note: "This lens has a limitation though: it only brings rays in focus that come from a plane directly in front of it, the focal plane. If the rays don't hit in quite the right spot, it leads to a blurring based on how distant the object is from the focal plane. Let's look at rays from a single point to see how this happens."},
      { rayGrouping: 1,
        note: "Since these rays are all at the same point on the sensor, we want all of them to hit the same point in the scene, and with the lens redirecting them, they will hit the right spot on the focal plane."},
      { rayDistance: 0.5,
        note: "However, if the rays hit an object that's closer..."},
      { rayDistance: 1.5,
        note: "Or more distant... then the rays don't hit in quite the right spot, leading to a blurring based on how distant the object is from the focal plane."},
      { rayGrouping: 0},
      { rayDistance: 1, deviation: 0},
      { gaussFade: 255,
        note: "Next, I'd like to discuss Gauss' Thin Lens Equation. This equation describes the relationship between sensor distance (s), focal plane distance (p), and focal length (f). Let's see what happens when each are adjusted."},
      { f: 1.1,
        note: "Adjusting the focal length affects the field of view of the camera, enabling a wider or more narrow view of the surroundings. This is illustrated by the way the rays spread wider or narrower. Note how s, the sensor distance, must also be adjusted to maintain the target focal distance."},
      { f: 0.5},
      { f: 1,
        note: "Likewise, we can adjust the focal plane distance. On a real camera, this is accomplished by adjusting s, just as we do in the illustration."},
      { p: 1.6},
      { p: 2.5},
      { p: 2},
      { correction: 0, 
        deviation: 1,
        note: "The aperture controls how open the lens is."},
      { n: 10,
        note: "When it gets smaller, less light gets in, but most of the light that is allowed to pass will be more focused, even without lens correction. In real life, this requires longer exposure time to allow more light to enter but means minimal depth of field."},
      { n: 1000,
        note: "A sufficiently small aperture will keep everything perfectly in focus. In real life though, no light would be allowed to pass. In the digital world, we can simulate only the rays that pass through the aperture."},
      { n: 2,
        note: "A large aperture makes the depth of field effect more intense as more rays are allowed to enter that may not be well-aligned."},
      { n: 1},
      { n: 2,
        note: "Now that we've covered the basics, let's discuss the extensions I've made for this project, tilt and shift."},
      { correction: 1,
        deviation: 0,
        gaussFade: 0,
        note: "Shift occurs when the image sensor is translated to be off-center from the lens. This is useful when you want to compensate for perspective effects."},
      { shift: [0,1]},
      { content: "images/shift1.png",
        note: "For instance, if you're photographing architecture but want to shift your vantage point, you would traditionally rotate the camera to the side, but this introduces perspective, so building lines are no longer straight. If we instead shift the sensor, we can compensate for this and maintain a straight shot even at a side vantage. You can see here that the lines are at an angle when you rotate the camera, but when you instead shift it, the horizontal lines remain straight. "},
      { content: "images/shift2.png",
        note: "In another example shot, we are photographing a building at street level but want a higher vantage. Traditionally this is accomplished by rotating the camera upward, but this introduces perspective, where higher up the building is farther than the bottom. If we instead shift the sensor, we can compensate for this and maintain a straight shot even at a higher vantage. If it makes it easier to understand, it's like using a camera with a larger sensor and cropping on an edge, where rays are traveling more to the side. Let me show you."},
      {},
      { shift: [0,0],
        sensorSize: 5.4,
        note: "Here, I have increased the size of the image sensor. Note how the rays at the top remain in the same spot, at the same angle."},
      { shift: [0,0],
        sensorSize: 1.8,
        note: "It's also useful for certain \"impossible shots.\""},
      { content: "images/Mirror-Portrait-Taken-with-Tilt-Shift-Lens.jpg",
        note: "Here, a subject is framed in a mirror but the camera is nowhere in sight, even though it looks like the camera should be directly in front of the mirror. In reality, the camera is to the side, with the sensor shifted for framing."},
      { shift: [0,-1],
        note: "It's also useful for certain \"impossible shots\", where a subject is framed in a mirror but the camera is nowhere in sight, even though it looks like the camera should be directly in front of the mirror. In reality, the camera is to the side, with the sensor shifted for framing."},
      { shift: [0,0],
        note: "Tilt is far more interesting to me. It tilts the lens to adjust the angle of the focal plane."},
      { tilt: [0,1,-1],
        note: "Since the focal plane is where the image is in focus, we can define essentially an arbitrary plane of perfect focus."},
      { tilt: [0,-1.5,-1],
        note: "This is useful for photographing two, or even three, subjects in perfect focus while maintaining a shallow, blurry depth of field."},
      { tilt: [0,0,-1]},];
      // Accumulate all previous changes to each parameter change.
      var accumulatedParams = {};
      Object.assign(accumulatedParams, paramChanges[0]);
      for (var i = 1; i < paramChanges.length; i++) {
        for (var param in paramChanges[i]) {
          accumulatedParams[param] = paramChanges[i][param];
        }
        Object.assign(paramChanges[i], accumulatedParams);
        delete accumulatedParams["content"];
      }
      // Add an empty, labeled fragment for each element of the paramChanges array.
      var visualSlide = document.getElementById("visual");
      for (var i = 1; i < paramChanges.length; i++) {
        // Add extra content in special cases.
        if("content" in paramChanges[i]) {
          var frag = document.createElement("img");
          frag.classList.add("fade-in-then-out");
          frag.src = paramChanges[i]["content"];
          frag.style.float = "left";
          frag.style.position = "absolute";
          frag.style.left = "0%";
          frag.style.top = "0%";

        } else {
          var frag = document.createElement("p");
        }
        frag.classList.add("fragment");
        if("note" in paramChanges[i]) {
          var note = document.createElement("aside");
          note.classList.add("notes");
          note.textContent = paramChanges[i]["note"];
          frag.appendChild(note);
        }
        visualSlide.appendChild(frag);
      }

      var reverse = false;
      Reveal.addEventListener( 'fragmentshown', function(event) {
        reverse = false;
        updateVisualization(event);
      } );
      // Reverse animations if slides move backwards.
      Reveal.addEventListener( 'fragmenthidden', function(event) {
        reverse = true;
        updateVisualization(event);
      } );

      function updateVisualization(event) {
        var step = Reveal.getIndices().f + 1;
        if(paramChanges[step]["noAnimate"] == true) {
          for (var param in paramChanges[step]) {
            if(param == "noAnimate") {
              continue;
            }
            if(param == "shift") {
              shift[0] = paramChanges[step][param][0];
              shift[1] = paramChanges[step][param][1];
            }
            else if(param == "tilt") {
              tilt[0] = paramChanges[step][param][0];
              tilt[1] = paramChanges[step][param][1];
              tilt[2] = paramChanges[step][param][2];
            }
            else if(param == "diagramFade") {
              diagramFade = padLeadingZeros(Number(this.value).toString(16),2);
            }
            else if(param == "gaussFade") {
              gaussFade = padLeadingZeros(Number(this.value).toString(16),2);
            }
            else {
              window[param] = paramChanges[step][param];
            }
          }
          s = (p*f)/(p-f);
          aperture = f/n;
          basis_u = twgl.v3.normalize(twgl.v3.cross(tilt,
                          Math.abs(tilt.x) > Math.abs(tilt.y)
                          ? [0,1,0] : [1,0,0]));
          basis_v = twgl.v3.cross(tilt, basis_u);
          draw();
        }
        else {
          start = undefined;
          done = false;
          window.requestAnimationFrame(stepFunc);
        }
      };

      let start, previousTimeStamp;
      let done = false;
      function stepFunc(timestamp) {
        if (start === undefined) {
          start = timestamp;
        }
        const elapsed = timestamp - start;

        if (previousTimeStamp !== timestamp) {
          // Math.min() is used here to make sure the element stops at exactly 200px
          const count = Math.min(elapsed/2000, 1);
          computeAnimation(count);
          if (count === 1) done = true;
        }

        if (elapsed < 2000) { // Stop the animation after 2 seconds
          previousTimeStamp = timestamp
          !done && window.requestAnimationFrame(stepFunc);
        }
      }

      function computeAnimation(pct) {
        var step = Reveal.getIndices().f + 1;
        var prevStep, nextStep;
        if(reverse) {
          prevStep = step + 1;
          nextStep = step;
        }
        else {
          prevStep = step - 1;
          nextStep = step;
        }
        for (var param in paramChanges[nextStep]) {
          if(param == "shift") {
            shift[0] = paramChanges[nextStep][param][0]*pct +
                       paramChanges[prevStep][param][0]*(1-pct);
            shift[1] = paramChanges[nextStep][param][1]*pct +
                       paramChanges[prevStep][param][1]*(1-pct);
          }
          else if(param == "tilt") {
            tilt = twgl.v3.add(twgl.v3.mulScalar(paramChanges[nextStep][param],pct),
                               twgl.v3.mulScalar(paramChanges[prevStep][param],1-pct));
          }
          else if(param == "diagramFade") {
              diagramFade = padLeadingZeros((Math.floor(paramChanges[nextStep][param]*pct+
                                                        paramChanges[prevStep][param]*(1-pct))).toString(16),2);
            }
            else if(param == "gaussFade") {
              gaussFade = padLeadingZeros((Math.floor(paramChanges[nextStep][param]*pct+
                                                      paramChanges[prevStep][param]*(1-pct))).toString(16),2);
            }
          else {
            window[param] = paramChanges[nextStep][param]*pct+paramChanges[prevStep][param]*(1-pct);
          }
        }
        s = (p*f)/(p-f);
        aperture = f/n;
        basis_u = twgl.v3.normalize(twgl.v3.cross(tilt,
                        Math.abs(tilt.x) > Math.abs(tilt.y)
                        ? [0,1,0] : [1,0,0]));
        basis_v = twgl.v3.cross(tilt, basis_u);
        draw();
      }
		</script>
	</body>
</html>